ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Runtime View


[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the system’s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...


.Further Information

See https://docs.arc42.org/section-6/[Runtime View] in the arc42 documentation.

****

=== User plays a match. Only one question batch is needed.

[plantuml,"Question generation 1",png]
----
autonumber

actor "User" as user

user -> "Game Service": Begins game
"Game Service" -> "Question Service" : Requests n questions
"Question Service" -> "Wikidata REST API" : Requests information to create questions
"Wikidata REST API" -> "Question Service" : Returns information
"Question Service" -> "Question Service" : Creates questions
"Question Service" -> "Game Service" : Returns questions

loop n times
    "Game Service" -> user : Shows question
    …
    user -> "Game Service" : Responds question
end

"Game Service" -> "Question Historic Service" : Sends the shown questions
"Game Service" -> "Player Statistics Service" : Sends the  user's match data
----

In circumstances in which few questions are needed for the game, it may be possible to extract all of them in a batch without affecting performance and response times. Besides, extracting them this way opens up the possibility of using multiple threads to gather the data, greatly increasing performance. However, if the querying times are too high, this strategy may cause great delays while loading the game. A possible alternative is explained below:

=== User plays a match. An example of dynamic question generation.

[plantuml,"Question generation 2",png]
----
autonumber

actor "User" as user

user -> "Game Service": Begins game
"Game Service" -> "Question Service" : Requests n questions
"Question Service" -> "Wikidata REST API" : Requests information to create questions
"Wikidata REST API" -> "Question Service" : Returns information
"Question Service" -> "Game Service" : Returns questions

loop Until the game ends
    loop n-k times
        "Game Service" -> user : Shows question
        ...
        user -> "Game Service" : Responds question
    end

    "Game Service" -> "Question Service" : Requests n questions
    "Question Service" -> "Wikidata REST API" : Requests information to create questions
    "Wikidata REST API" -> "Question Service" : Returns information
    "Question Service" -> "Question Service" : Creates questions
    "Question Service" -> "Game Service" : Returns questions

    loop k times
        "Game Service" -> user : Shows question
        ...
        user -> "Game Service" : Responds question
    end
end

"Game Service" -> "Question Historic Service" : Sends the shown questions
"Game Service" -> "Player Statistics Service" : Sends the  user's match data
----

In cases where a lot of questions are needed, or wikidata querying has a great impact on performance, this alternative may prove to be convenient. By distributing the data fetching along the entire match, bottlenecks on performance will be reduced. Depending on the system load (or, optionally client device's specifications!) batch sizes may vary, adapting to maintain responsiveness.

=== User consults its game statistics.

[plantuml,"Consult Statistics",png]
----
autonumber

actor "User" as user

user -> "Player Statistics Service" : Requests user data
"Player Statistics Service" -> "MongoDB Server" : Makes petition through REST API
"MongoDB Server" -> "Player Statistics Service" : Returns information
"Player Statistics Service" -> user : Shows data
----

=== User consults questions used in games.

[plantuml,"Consult questions",png]
----
autonumber

actor "User" as user

user -> "Question Historic Service" : Requests user data
"Question Historic Service" -> "MongoDB Server" : Makes petition through REST API
"MongoDB Server" -> "Question Historic Service" : Returns information
"Question Historic Service" -> user : Shows data
----
